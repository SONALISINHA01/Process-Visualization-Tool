import psutil
import random

# Step 1: Fetch Real Processes
def get_running_processes():
    """
    Fetches the list of real processes running on the system.
    Returns:
        list: List of dictionaries containing process details (pid, name, cpu_usage, memory_usage).
    """
    processes = []
    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_info']):
        try:
            # Get process details
            pid = proc.info['pid']
            name = proc.info['name']
            cpu_usage = proc.info['cpu_percent']
            memory_usage = proc.info['memory_info'].rss  # Resident Set Size (memory usage in bytes)
            processes.append({
                'pid': pid,
                'name': name,
                'cpu_usage': cpu_usage,
                'memory_usage': memory_usage
            })
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # Skip processes that can't be accessed
            pass
    return processes

# Step 2: Map Real Processes to Your Scheduling Algorithms
class Process:
    """
    Represents a process with attributes like pid, name, arrival_time, burst_time, etc.
    """
    def __init__(self, pid, name, arrival_time, burst_time, cpu_usage, memory_usage):
        self.pid = pid
        self.name = name
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.cpu_usage = cpu_usage
        self.memory_usage = memory_usage
        self.remaining_time = burst_time
        self.state = "New"
        self.waiting_time = 0
        self.turnaround_time = 0

    def __str__(self):
        return f"Process {self.pid} ({self.name}): State={self.state}, Waiting Time={self.waiting_time}, Turnaround Time={self.turnaround_time}"

def create_process_objects(processes):
    """
    Converts the list of fetched processes into Process objects.
    Args:
        processes (list): List of dictionaries containing process details.
    Returns:
        list: List of Process objects.
    """
    process_objects = []
    for i, proc in enumerate(processes):
        arrival_time = i  # Simulate arrival time
        burst_time = random.randint(1, 10)  # Assign a random burst time between 1 and 10
        process = Process(
            pid=proc['pid'],
            name=proc['name'],
            arrival_time=arrival_time,
            burst_time=burst_time,
            cpu_usage=proc['cpu_usage'],
            memory_usage=proc['memory_usage']
        )
        process_objects.append(process)
    return process_objects

# Step 3: Scheduling Algorithms
def fcfs(processes):
    """
    Implements the First-Come, First-Served scheduling algorithm.
    Args:
        processes (list): List of Process objects.
    Returns:
        list: List of processes with updated waiting_time and turnaround_time.
    """
    processes.sort(key=lambda x: x.arrival_time)  # Sort by arrival time
    current_time = 0
    for process in processes:
        if current_time < process.arrival_time:
            current_time = process.arrival_time
        process.waiting_time = current_time - process.arrival_time
        process.turnaround_time = process.waiting_time + process.burst_time
        current_time += process.burst_time
        process.state = "Terminated"  # Process completes execution
    return processes

# Step 4: Main Function to Run Everything
if __name__ == "__main__":
    # Fetch real processes
    print("Fetching real processes...")
    processes = get_running_processes()

    # Convert to Process objects
    print("Creating process objects...")
    process_objects = create_process_objects(processes)

    # Run FCFS
    print("\nFCFS Results:")
    fcfs_processes = fcfs(process_objects.copy())
    for process in fcfs_processes:
        print(process)
